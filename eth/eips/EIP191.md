## EIP-191

### 概念简介

EIP-191（Signed Data Standard）是以太坊的签名数据标准，定义了如何在以太坊中处理签名数据的规范。这个标准于 2016 年由 Martin Holst Swende 和 Nick Johnson 提出，旨在防止签名重放攻击并确保不同实现之间的一致签名行为。

EIP-191 通过引入特殊的前缀和版本机制，确保签名的消息不会被误认为是有效的以太坊交易。

### 背景和动机

**签名重放攻击**
在 EIP-191 之前，签名消息可能被重放为交易：
- 签名的数据结构可能与交易相同
- 恶意者可以将签名提交为实际交易
- 导致意外的资金转移或操作

**一致性问题**
不同的钱包和应用使用不同的签名格式：
- 缺乏统一标准
- 签名验证困难
- 互操作性差

### 核心格式

**标准签名格式**
EIP-191 定义的签名数据格式：
```
0x19 <1 byte version> <version specific data> <data to sign>
```

**关键组成部分**

1. **0x19 前缀**
   - 固定的单字节前缀
   - 选择 0x19 因为它使 RLP 编码无效
   - 确保签名数据不能被解析为有效交易
   - 防止签名重放攻击

2. **版本字节**
   - 区分不同的签名方法
   - 支持多种签名用途
   - 便于未来扩展

3. **版本特定数据**
   - 根据版本字节的不同而变化
   - 提供额外的上下文信息
   - 增强安全性

4. **要签名的数据**
   - 实际需要签名的内容
   - 应用自定义数据

### 三种版本类型

**版本 0x00：数据与预期验证器**
```
0x19 0x00 <intended validator address> <data to sign>
```

- 用途：绑定到特定的验证合约
- 场景：合约签名验证
- 示例：特定智能合约验证的签名

```solidity
// 签名格式
bytes memory message = abi.encodePacked(
    byte(0x19),
    byte(0x00),
    validatorAddress,
    dataToSign
);
bytes32 hash = keccak256(message);
```

**版本 0x01：结构化数据（EIP-712）**
```
0x19 0x01 <domainSeparator> <hashStruct(message)>
```

- 用途：保留给 EIP-712
- 场景：结构化数据签名
- 示例：授权、许可、订单签名

当版本字节为 0x01 时，钱包和工具会识别为 EIP-712 格式，提供更友好的签名展示。

**版本 0x45：个人签名消息**
```
0x19 0x45 (E for Ethereum) thereum Signed Message:\n<length><data>
```

完整格式：
```
"\x19Ethereum Signed Message:\n" + len(message) + message
```

- 用途：人类可读的消息签名
- 场景：登录验证、消息证明
- 示例：`personal_sign` RPC 方法

```javascript
// 使用 ethers.js
const message = "Hello World"
const signature = await signer.signMessage(message)

// 实际签名的是：
// "\x19Ethereum Signed Message:\n11Hello World"
```

### 实际应用

**登录验证**
```javascript
// 前端：生成签名
const message = `登录到 MyApp\n时间戳: ${Date.now()}`
const signature = await signer.signMessage(message)

// 后端：验证签名
const recoveredAddress = ethers.verifyMessage(message, signature)
if (recoveredAddress === expectedAddress) {
    // 登录成功
}
```

**链下授权**
```solidity
contract MyContract {
    function verifySignature(
        bytes32 hash,
        bytes memory signature
    ) public pure returns (address) {
        // 添加 EIP-191 前缀
        bytes32 ethSignedHash = keccak256(
            abi.encodePacked("\x19Ethereum Signed Message:\n32", hash)
        );

        // 恢复签名者地址
        return ECDSA.recover(ethSignedHash, signature);
    }
}
```

**元交易签名**
```javascript
// 构造符合 EIP-191 版本 0x00 的签名
const message = ethers.solidityPacked(
    ['bytes1', 'bytes1', 'address', 'bytes'],
    ['0x19', '0x00', contractAddress, encodedData]
)
const hash = ethers.keccak256(message)
const signature = await signer.signMessage(ethers.getBytes(hash))
```

### 安全特性

**防止交易重放**
0x19 前缀确保签名数据的 RLP 编码无效：
- 以太坊交易的 RLP 编码不会以 0x19 开头
- 签名消息永远不会被误认为交易
- 完全防止签名重放攻击

**域分隔**
不同版本的签名用于不同目的：
- 防止跨用途重放
- 清晰的语义
- 便于验证和审计

**合约绑定**
版本 0x00 将签名绑定到特定合约：
- 签名只能被指定合约验证
- 防止跨合约重放
- 增强安全性

### 与 EIP-712 的关系

**EIP-712 建立在 EIP-191 之上**
EIP-712 使用 EIP-191 的版本 0x01：
```
0x19 0x01 <domainSeparator> <hashStruct>
```

**职责分工**
- **EIP-191**：定义签名数据的低级格式
- **EIP-712**：定义结构化数据的高级格式

**兼容性**
所有 EIP-712 签名都是有效的 EIP-191 签名（版本 0x01）。

### 开发示例

**Solidity 验证**
```solidity
import "@openzeppelin/contracts/utils/cryptography/ECDSA.sol";

contract SignatureVerifier {
    using ECDSA for bytes32;

    function verifyPersonalSignature(
        string memory message,
        bytes memory signature
    ) public pure returns (address) {
        bytes32 messageHash = keccak256(abi.encodePacked(message));

        // 应用 EIP-191 前缀（版本 0x45）
        bytes32 ethSignedHash = messageHash.toEthSignedMessageHash();

        // 恢复签名者
        return ethSignedHash.recover(signature);
    }

    function verifyDataWithValidator(
        address validator,
        bytes memory data,
        bytes memory signature
    ) public pure returns (address) {
        // EIP-191 版本 0x00
        bytes32 hash = keccak256(
            abi.encodePacked(
                bytes1(0x19),
                bytes1(0x00),
                validator,
                data
            )
        );

        return hash.recover(signature);
    }
}
```

**JavaScript 签名和验证**
```javascript
import { ethers } from 'ethers'

// 个人签名（版本 0x45）
async function personalSign(message, signer) {
    // ethers.js 自动添加 EIP-191 前缀
    const signature = await signer.signMessage(message)
    return signature
}

// 验证个人签名
function verifyPersonalSignature(message, signature) {
    const recoveredAddress = ethers.verifyMessage(message, signature)
    return recoveredAddress
}

// 手动构造 EIP-191 版本 0x00 签名
async function signWithValidator(validatorAddress, data, signer) {
    const message = ethers.solidityPacked(
        ['bytes1', 'bytes1', 'address', 'bytes'],
        ['0x19', '0x00', validatorAddress, data]
    )
    const hash = ethers.keccak256(message)

    // 直接签名哈希（不再添加前缀）
    const sig = await signer.signMessage(ethers.getBytes(hash))
    return sig
}
```

### 常见陷阱

**重复添加前缀**
```javascript
// ❌ 错误：重复添加前缀
const hash = ethers.keccak256(message)
const signature = await signer.signMessage(hash) // signMessage 已经添加了前缀

// ✅ 正确：要么使用 signMessage
const signature = await signer.signMessage(message)

// ✅ 或者手动构造完整格式后使用 _signTypedData
```

**混淆版本**
不同版本用于不同场景，不要混用：
- 个人消息用版本 0x45
- 结构化数据用版本 0x01（EIP-712）
- 合约验证用版本 0x00

**链 ID 考虑**
EIP-191 本身不包含链 ID：
- 可能导致跨链重放
- 建议在消息中包含链 ID
- 或使用 EIP-712（包含链 ID）

### 最佳实践

**选择正确的版本**
- 简单消息签名：使用版本 0x45（`personal_sign`）
- 结构化数据：使用版本 0x01（EIP-712）
- 合约特定签名：使用版本 0x00

**包含时间戳和 nonce**
```javascript
const message = {
    action: "transfer",
    timestamp: Date.now(),
    nonce: userNonce,
    // ...其他数据
}
```

**使用 OpenZeppelin**
```solidity
import "@openzeppelin/contracts/utils/cryptography/ECDSA.sol";
import "@openzeppelin/contracts/utils/cryptography/MessageHashUtils.sol";

// 利用标准库避免错误
```

### 生态系统影响

**钱包标准化**
所有主流钱包都支持 EIP-191：
- MetaMask
- WalletConnect
- Coinbase Wallet
- Ledger, Trezor 等硬件钱包

**开发工具支持**
标准库内置支持：
- Ethers.js：`signMessage()`, `verifyMessage()`
- Web3.js：`eth.personal.sign()`, `eth.personal.ecRecover()`
- OpenZeppelin：ECDSA 库

**DApp 集成**
EIP-191 已成为：
- 登录验证的事实标准
- 链下签名的基础
- EIP-712 的基石

### 历史意义

EIP-191 是以太坊生态系统中的重要基础设施：
- 2016 年提出，解决了早期签名安全问题
- 为 EIP-712 铺平了道路
- 成为链下签名的标准格式
- 至今仍广泛使用

### 相关链接

- [EIP-191 官方规范](https://eips.ethereum.org/EIPS/eip-191)
- [理解 EIP-191（Medium）](https://medium.com/@sanhdoan/understanding-eip-191-signed-data-standard-in-ethereum-748b1c4d7bcc)
- [EIP-191 与 EIP-712 对比（Cyfrin）](https://www.cyfrin.io/blog/understanding-ethereum-signature-standards-eip-191-eip-712)
- [OpenZeppelin ECDSA 库](https://docs.openzeppelin.com/contracts/4.x/api/utils#ECDSA)
