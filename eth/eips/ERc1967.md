## ERC-1967: 代理存储槽标准 (Proxy Storage Slots)

ERC-1967 是一个关于如何在代理合约（Proxy Contracts）中安全存储特定数据的标准，旨在避免存储冲突（Storage Collisions）。

### 解决的问题
在可升级合约的代理模式中，代理合约（Proxy）使用 `delegatecall` 将调用转发给逻辑合约（Implementation）。这意味着逻辑合约的代码在代理合约的存储上下文中运行。
如果代理合约和逻辑合约使用相同的存储槽（例如，代理合约在 slot 0 存储逻辑合约地址，而逻辑合约也在 slot 0 存储 `owner` 变量），就会发生**存储冲突**，导致数据互相覆盖，引发严重漏洞。
为了解决这个问题，代理合约需要将其特定的状态变量（如逻辑合约地址、管理员地址）存储在逻辑合约永远不会使用的位置。

### 实现机制与原理
ERC-1967 定义了特定的、伪随机的存储槽位置，这些位置通过哈希算法计算得出，且距离极远，实际上不可能与 Solidity 编译器分配的普通状态变量冲突。

标准定义的存储槽如下：

1.  **Implementation Slot (逻辑合约地址):**
    *   存储逻辑合约（Implementation）的地址。
    *   计算公式: `bytes32(uint256(keccak256('eip1967.proxy.implementation')) - 1)`
    *   值: `0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc`

2.  **Admin Slot (管理员地址):**
    *   存储有权升级合约的管理员地址。
    *   计算公式: `bytes32(uint256(keccak256('eip1967.proxy.admin')) - 1)`
    *   值: `0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103`

3.  **Beacon Slot (信标地址):**
    *   用于 Beacon Proxy 模式，存储 Beacon 合约的地址。
    *   计算公式: `bytes32(uint256(keccak256('eip1967.proxy.beacon')) - 1)`
    *   值: `0xa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6cb3582b35133d50`

### 主要特点
*   **标准化:** 区块浏览器（如 Etherscan）可以识别这些槽位，从而自动检测合约是否为代理合约，并展示“Read as Proxy”和“Write as Proxy”的功能。
*   **安全性:** 保证了代理合约的关键配置不会被逻辑合约意外覆盖。
*   **非结构化存储:** 这种模式被称为“非结构化存储”模式，因为这些变量不在 [Solidity](https://learnblockchain.cn/tags/Solidity?map=EVM) 的常规存储布局中声明。

### 推荐阅读
*   [ERC-1967 Standard](https://learnblockchain.cn/docs/eips/EIPS/eip-1967)
*   [OpenZeppelin: Proxy Patterns](https://blog.openzeppelin.com/proxy-patterns/)
