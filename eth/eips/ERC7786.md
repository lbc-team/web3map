## ERC-7786

### 概念简介

ERC-7786（Cross-Chain Messaging Gateway）是以太坊的跨链消息传递网关标准，于 2024 年 10 月发布。这个标准提供了一个统一的接口，用于合约之间发送和接收包含任意数据的跨链消息，旨在解决当前跨链通信协议碎片化的问题。

ERC-7786 是以太坊基金会互操作性工作组（Interoperability Working Group）倡议的一部分，致力于创建真正可互操作的区块链生态系统。

### 背景问题

**跨链协议碎片化**
目前的跨链通信生态面临严重的碎片化：
- LayerZero、Axelar、Wormhole、Hyperlane 等协议各自为政
- 每个协议有自己的接口和工作流程
- 应用需要为每个协议编写适配代码
- 无法轻松切换或同时使用多个协议

**开发者困境**
```solidity
// 使用 LayerZero
function sendToLayerZero(...) {
    lzEndpoint.send(...);
}

// 使用 Axelar
function sendToAxelar(...) {
    axelarGateway.callContract(...);
}

// 使用 Wormhole
function sendToWormhole(...) {
    wormholeRelayer.sendPayloadToEvm(...);
}

// 每个协议都需要不同的代码！
```

**供应商锁定**
- 一旦选择某个协议，很难迁移
- 被单一协议的限制和风险绑定
- 无法利用多个协议的优势

### ERC-7786 的解决方案

**统一接口**
一个标准化的网关接口，所有跨链协议都可以实现：
```solidity
interface IGateway {
    function sendMessage(CrossChainMessage calldata message) external payable returns (bytes32 messageId);
    function receiveMessage(CrossChainMessage calldata message) external;
}
```

**适配器模式**
现有协议可以通过适配器实现 ERC-7786：
```
应用合约 → ERC-7786 Gateway → 适配器 → 底层协议
```

**协议无关**
应用可以轻松切换协议或同时使用多个协议。

### 核心概念

**CrossChainMessage**
跨链消息的标准结构：
```solidity
struct CrossChainMessage {
    address sender;              // 发送者地址
    uint256 sourceChainId;       // 源链 ID
    address recipient;           // 接收者地址
    uint256 destinationChainId;  // 目标链 ID
    bytes payload;               // 消息负载
    uint256 value;               // 原生代币数量
    Attribute[] attributes;      // 可扩展属性
}
```

**Attribute（属性）**
可扩展的键值对系统：
```solidity
struct Attribute {
    bytes32 key;    // 属性类型
    bytes value;    // 属性数据
}
```

属性示例：
- 超时时间
- 重试策略
- 费用支付方式
- 安全级别
- 执行条件

### 核心接口

**发送消息**
```solidity
function sendMessage(
    CrossChainMessage calldata message
) external payable returns (bytes32 messageId);
```

**接收消息**
```solidity
function receiveMessage(
    CrossChainMessage calldata message
) external;
```

**查询功能**
```solidity
// 检查网关能力
function supportsAttribute(bytes32 attributeKey) external view returns (bool);

// 估算费用
function estimateFee(CrossChainMessage calldata message) external view returns (uint256);

// 查询消息状态
function getMessageStatus(bytes32 messageId) external view returns (MessageStatus);
```

**事件**
```solidity
event MessageSent(
    bytes32 indexed messageId,
    address indexed sender,
    uint256 indexed destinationChainId,
    address recipient,
    bytes payload
);

event MessageReceived(
    bytes32 indexed messageId,
    address indexed recipient,
    uint256 indexed sourceChainId,
    address sender,
    bytes payload
);
```

### 实现示例

**应用合约**
```solidity
contract CrossChainApp {
    IGateway public gateway;

    constructor(address _gateway) {
        gateway = IGateway(_gateway);
    }

    // 发送跨链消息
    function sendCrossChain(
        uint256 destinationChainId,
        address recipient,
        bytes calldata data
    ) external payable {
        CrossChainMessage memory message = CrossChainMessage({
            sender: address(this),
            sourceChainId: block.chainid,
            recipient: recipient,
            destinationChainId: destinationChainId,
            payload: data,
            value: 0,
            attributes: new Attribute[](0)
        });

        bytes32 messageId = gateway.sendMessage{value: msg.value}(message);
        emit CrossChainSent(messageId, destinationChainId, recipient);
    }

    // 接收跨链消息
    function receiveMessage(
        CrossChainMessage calldata message
    ) external {
        require(msg.sender == address(gateway), "Only gateway");

        // 处理消息
        _handleMessage(message.payload);

        emit CrossChainReceived(message.sourceChainId, message.sender);
    }

    function _handleMessage(bytes calldata payload) internal {
        // 解码并处理消息
        // ...
    }
}
```

**网关适配器（LayerZero 示例）**
```solidity
contract LayerZeroGateway is IGateway {
    ILayerZeroEndpoint public lzEndpoint;

    function sendMessage(
        CrossChainMessage calldata message
    ) external payable returns (bytes32) {
        // 将 ERC-7786 消息转换为 LayerZero 格式
        uint16 dstChainId = _chainIdToLZ(message.destinationChainId);
        bytes memory payload = abi.encode(message);

        // 通过 LayerZero 发送
        lzEndpoint.send{value: msg.value}(
            dstChainId,
            abi.encodePacked(message.recipient),
            payload,
            payable(msg.sender),
            address(0),
            bytes("")
        );

        return keccak256(abi.encode(message));
    }

    // LayerZero 回调
    function lzReceive(
        uint16 _srcChainId,
        bytes calldata _srcAddress,
        uint64 _nonce,
        bytes calldata _payload
    ) external override {
        require(msg.sender == address(lzEndpoint), "Only endpoint");

        // 解码消息
        CrossChainMessage memory message = abi.decode(_payload, (CrossChainMessage));

        // 转发给接收者
        ICrossChainReceiver(message.recipient).receiveMessage(message);

        emit MessageReceived(...);
    }
}
```

### 属性系统

**标准属性**
ERC-7786 定义了一些推荐的标准属性：

**超时属性**
```solidity
bytes32 constant TIMEOUT_KEY = keccak256("erc7786.timeout");

Attribute memory timeoutAttr = Attribute({
    key: TIMEOUT_KEY,
    value: abi.encode(block.timestamp + 1 hours)
});
```

**费用支付方式**
```solidity
bytes32 constant FEE_PAYMENT_KEY = keccak256("erc7786.feePayment");

enum FeePayment {
    Source,        // 在源链支付
    Destination,   // 在目标链支付
    ThirdParty     // 第三方支付
}

Attribute memory feeAttr = Attribute({
    key: FEE_PAYMENT_KEY,
    value: abi.encode(FeePayment.Source)
});
```

**执行 Gas 限制**
```solidity
bytes32 constant GAS_LIMIT_KEY = keccak256("erc7786.gasLimit");

Attribute memory gasAttr = Attribute({
    key: GAS_LIMIT_KEY,
    value: abi.encode(500000)
});
```

**自定义属性**
协议可以定义自己的属性：
```solidity
bytes32 constant CUSTOM_SECURITY_KEY = keccak256("myprotocol.security.level");

Attribute memory securityAttr = Attribute({
    key: CUSTOM_SECURITY_KEY,
    value: abi.encode("high")
});
```

### 关键优势

**互操作性**
- 应用编写一次代码
- 兼容所有实现 ERC-7786 的协议
- 轻松切换或组合多个协议

**降低供应商锁定**
```solidity
// 可以轻松切换协议
gateway = new LayerZeroGateway();
// 或
gateway = new AxelarGateway();
// 或
gateway = new HyperlaneGateway();

// 应用代码无需修改！
```

**简化开发**
- 统一的接口
- 减少学习成本
- 更少的集成代码
- 标准化的最佳实践

**协议竞争**
- 协议间可互换
- 促进创新和优化
- 用户选择最佳方案

**可扩展性**
- 属性系统支持新功能
- 向后兼容
- 灵活适应需求变化

### 应用场景

**跨链 DeFi**
```solidity
// 在 Ethereum 上借款，在 Arbitrum 上使用
function crossChainLend(
    uint256 amount,
    uint256 targetChainId,
    address borrowerOnTarget
) external {
    // 在源链锁定资金
    _lockCollateral(amount);

    // 发送跨链消息到目标链
    CrossChainMessage memory message = CrossChainMessage({
        sender: address(this),
        sourceChainId: block.chainid,
        recipient: targetProtocol,
        destinationChainId: targetChainId,
        payload: abi.encodeWithSignature(
            "releaseLoan(address,uint256)",
            borrowerOnTarget,
            amount
        ),
        value: 0,
        attributes: new Attribute[](0)
    });

    gateway.sendMessage(message);
}
```

**跨链 NFT**
```solidity
// NFT 在链间移动
function bridgeNFT(uint256 tokenId, uint256 targetChainId) external {
    require(ownerOf(tokenId) == msg.sender, "Not owner");

    // 在源链销毁
    _burn(tokenId);

    // 通知目标链铸造
    CrossChainMessage memory message = CrossChainMessage({
        sender: address(this),
        sourceChainId: block.chainid,
        recipient: mirrorContractOnTarget,
        destinationChainId: targetChainId,
        payload: abi.encode(msg.sender, tokenId, _metadata[tokenId]),
        value: 0,
        attributes: new Attribute[](0)
    });

    gateway.sendMessage(message);
}
```

**跨链治理**
```solidity
// 主链发起提案，在多条链上执行
function executeMultiChainProposal(
    uint256[] calldata targetChains,
    bytes[] calldata payloads
) external onlyGovernance {
    for (uint i = 0; i < targetChains.length; i++) {
        CrossChainMessage memory message = CrossChainMessage({
            sender: address(this),
            sourceChainId: block.chainid,
            recipient: governanceExecutorOnTarget,
            destinationChainId: targetChains[i],
            payload: payloads[i],
            value: 0,
            attributes: new Attribute[](0)
        });

        gateway.sendMessage(message);
    }
}
```

**跨链身份**
用户在一条链上验证身份，在其他链上使用：
- 单点登录（SSO）
- 跨链信用评分
- 统一的会员系统

### 与其他标准的关系

**与 ERC-7683 的区别**
- **ERC-7683**：跨链意图（Intents），关注价值转移和交换
- **ERC-7786**：通用消息传递，支持任意数据和操作

两者可以互补使用：
- ERC-7683 用于跨链交易
- ERC-7786 用于跨链消息和状态同步

**与 EIP-5164 的关系**
EIP-5164 也是跨链消息标准，但：
- EIP-5164 更早，功能较少
- ERC-7786 更完整，支持属性系统
- ERC-7786 有更广泛的协议支持

### 实施挑战

**安全性**
- 消息验证：确保消息真实性
- 重放保护：防止消息重复执行
- 权限检查：验证发送者身份

**费用管理**
- 跨链费用计算复杂
- 费用支付方式多样
- 价格波动影响

**协议差异**
- 不同协议的安全模型不同
- 确认时间差异
- 功能支持不一致

**错误处理**
- 消息失败的回滚
- 超时处理
- 用户通知

### 采用情况

**协议支持**
以下协议正在实现或考虑 ERC-7786：
- Hyperlane
- LayerZero
- Wormhole
- Axelar
- Chainlink CCIP

**应用集成**
- 跨链 DEX
- 多链 DAO
- 跨链游戏
- 统一流动性池

### 开发工具

**OpenZeppelin 合约**
```solidity
import "@openzeppelin/contracts/crosschain/ERC7786Gateway.sol";

contract MyGateway is ERC7786Gateway {
    // 实现跨链逻辑
}
```

**测试工具**
```javascript
import { testERC7786Compliance } from '@erc7786/test-suite';

describe('MyGateway', () => {
    it('should comply with ERC-7786', async () => {
        await testERC7786Compliance(gateway);
    });
});
```

### 最佳实践

**消息设计**
- 保持 payload 紧凑
- 使用有效的编码
- 包含必要的上下文

**错误处理**
```solidity
function receiveMessage(CrossChainMessage calldata message) external {
    try this._handleMessage(message) {
        emit MessageSuccess(message.messageId);
    } catch Error(string memory reason) {
        emit MessageFailed(message.messageId, reason);
        // 可选：存储失败消息用于重试
    }
}
```

**重试机制**
```solidity
mapping(bytes32 => CrossChainMessage) public failedMessages;

function retryMessage(bytes32 messageId) external {
    CrossChainMessage memory message = failedMessages[messageId];
    gateway.sendMessage{value: msg.value}(message);
}
```

### 未来展望

**生态系统发展**
- 更多协议采用 ERC-7786
- 标准库和工具成熟
- 钱包和区块浏览器支持

**标准演进**
- 新的标准属性
- 更复杂的消息类型
- 与其他标准整合

**真正的链抽象**
ERC-7786 是实现链抽象的关键组件：
- 用户无需关心底层链
- 应用无缝跨链运行
- 流动性统一

### 相关链接

- [ERC-7786 官方规范](https://eips.ethereum.org/EIPS/eip-7786)
- [ERC-7786 官方网站](https://www.erc7786.org/)
- [以太坊互操作性工作组](https://ethereum.org/en/developers/docs/interoperability/)
- [OpenZeppelin 跨链文档](https://docs.openzeppelin.com/contracts/5.x/api/crosschain)
