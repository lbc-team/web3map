# EVM 字节码 (Bytecode)

EVM 字节码是以太坊虚拟机（EVM）能够理解和执行的机器语言。就像 CPU 只能执行二进制机器码一样，EVM 并不直接理解 Solidity 或 Vyper 等高级编程语言编写的智能合约源代码，而是执行由编译器生成的低级指令序列——字节码。

## 要解决的问题

以太坊旨在成为一台“世界计算机”，允许开发者编写任意逻辑的智能合约。为了实现这一目标，需要解决以下挑战：

1.  **平台无关性**：智能合约需要在全球成千上万个异构节点（不同的操作系统、硬件架构）上确切一致地运行。
2.  **资源控制**：由于区块链资源有限，必须精确计算每一步计算的成本（Gas），以防止滥用和无限循环。
3.  **代码紧凑性**：链上存储极为昂贵，执行代码需要尽可能紧凑以减少存储和部署成本。

EVM 字节码通过定义一套标准化的、与硬件无关的指令集，解决了上述问题。

## 实现机制与原理

### 编译过程
当开发者编写好 Solidity 合约后，编译器（如 `solc`）会将其转换为十六进制表示的字节码字符串（例如 `0x60806040...`）。

### 字节码结构
一个典型的合约字节码包含两个主要部分：
1.  **创建代码（Creation Code / Init Code）**：这部分代码只在合约部署时执行一次。它负责初始化合约状态（如构造函数逻辑），并返回**运行时代码**。
2.  **运行时代码（Runtime Code / Deployed Code）**：这是实际存储在区块链上的代码。当外部账户或其他合约调用该合约时，执行的就是这部分代码。

### 指令执行
字节码由一系列 **操作码（Opcodes）** 组成，每个操作码是一个字节（8位），代表一个特定的指令（如 `PUSH`, `ADD`, `SSTORE`）。
*   **取指**：EVM 程序计数器（PC）读取当前字节。
*   **解码**：将字节解析为对应的操作指令。
*   **执行**：EVM 根据指令对堆栈（Stack）、内存（Memory）或存储（Storage）进行操作。
*   **计费**：每条指令都有固定的 Gas 成本，EVM 会从交易提供的 Gas 总额中扣除相应费用。

## 主要特点

*   **基于堆栈（Stack-based）**：EVM 是一种堆栈机，大多数指令都是从堆栈顶部获取参数并将结果推回堆栈。这种设计简化了虚拟机的实现。
*   **图灵完备（Turing Complete）**：支持跳转（JUMP）等控制流指令，理论上可以执行任何计算逻辑（受限于 Gas）。
*   **沙盒环境**：字节码在 EVM 隔离环境中运行，无法直接访问网络、文件系统或其他进程，保证了安全性。
*   **Gas 计量**：每个字节码指令都有精确的 Gas 消耗定义，这在字节码层面强制实施了计算资源的经济模型。

## 推荐阅读

*   [Ethereum Yellow Paper](https://ethereum.github.io/yellowpaper/paper.pdf) (Appendix H 详细列出了所有操作码)
*   [EVM Opcodes Interactive Reference](https://www.evm.codes/)
*   [Deconstructing a Solidity Contract](https://blog.openzeppelin.com/deconstructing-a-solidity-contract-part-i-introduction-832efd2d7737/)

## 相关概念

*   **ABI (Application Binary Interface)**：虽然字节码定义了逻辑，ABI 定义了如何与字节码交互（如何编码函数调用和参数）。
*   **Disassembler (反汇编器)**：将十六进制字节码转换回可读的操作码助记符的工具。
*   **Decompiler (反编译器)**：尝试将字节码还原为类高级语言逻辑的工具，用于分析闭源合约。
