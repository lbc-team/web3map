# 比特币脚本

## 概念简介

比特币脚本(Bitcoin Script)是比特币网络中用于定义交易条件和验证规则的堆栈式编程语言。与图灵完备的智能合约语言不同,比特币脚本是一种故意设计为非图灵完备的简单脚本语言,由一系列操作码(Opcode)组成,用于验证比特币交易的合法性。

比特币脚本系统基于逆波兰表示法(RPN)的堆栈式执行模型,从左到右顺序执行,没有循环结构。这种设计确保了脚本的可预测性、安全性和验证效率。每个比特币交易都包含两个关键脚本:锁定脚本(ScriptPubKey)定义了花费条件,解锁脚本(ScriptSig)提供满足条件的数据。

比特币脚本语言虽然功能受限,但足以支持复杂的支付场景,包括多重签名、时间锁、哈希锁等。这种简洁性是比特币安全性和稳定性的基石,避免了许多智能合约平台面临的复杂性和漏洞风险。

## 核心特性

**堆栈式执行**

比特币脚本采用堆栈式(Stack-based)架构,所有操作都在堆栈上进行。数据被压入堆栈,操作码从堆栈中取出数据进行处理,然后将结果压回堆栈。脚本执行完成后,如果栈顶为真值(非零),则验证通过。这种执行模型简单高效,便于验证和审计。

**非图灵完备**

比特币脚本刻意设计为非图灵完备,不支持循环和递归。这意味着脚本的执行时间是可预测的,不会出现无限循环或"停机问题"。这种限制确保了节点可以快速验证交易,防止了拒绝服务攻击。

**UTXO模型集成**

比特币脚本与UTXO(未花费交易输出)模型紧密集成,每个UTXO都有一个锁定脚本定义花费条件,花费时需提供解锁脚本证明所有权。脚本验证逻辑如下:
- **锁定脚本(ScriptPubKey)**:定义接收条件,如"需要某公钥的有效签名"
- **解锁脚本(ScriptSig)**:提供满足条件的数据,如签名和公钥
- **验证过程**:先执行ScriptSig,再执行ScriptPubKey,若最终栈顶为真则交易有效

**操作码系统**

比特币脚本提供约200个操作码,可以分为几类:
- **常量操作码**:如 `OP_0`、`OP_1` 等,用于压入常量
- **流程控制**:如 `OP_IF`、`OP_ELSE`、`OP_ENDIF`,控制条件执行
- **堆栈操作**:如 `OP_DUP`(复制栈顶)、`OP_DROP`(丢弃栈顶)
- **算术运算**:如 `OP_ADD`、`OP_SUB`、`OP_EQUAL`
- **密码学操作**:如 `OP_HASH160`、`OP_CHECKSIG`(验证签名)
- **时间锁**:如 `OP_CHECKLOCKTIMEVERIFY`、`OP_CHECKSEQUENCEVERIFY`

部分操作码因安全原因被禁用(如 `OP_CAT`、`OP_MUL`),以防止潜在的漏洞利用。

**确定性执行**

比特币脚本的执行是完全确定性的,相同的脚本在任何时间任何节点上执行都会得到相同的结果。这确保了全网节点可以独立验证交易而达成共识。

## 技术优势

**安全性强**

堆栈式执行和有限的操作码集大幅降低了比特币脚本产生漏洞的可能性。脚本不能访问系统资源或外部数据,所有操作都受到严格限制,这使得安全审计更加容易。

**效率高**

简洁的脚本执行模型使得验证速度极快,即使资源受限的设备也能高效验证交易。脚本大小和执行时间都有明确的上限,保证了网络的可扩展性。

**灵活性与可扩展性**

虽然非图灵完备,但比特币脚本仍能支持多种复杂支付场景,如多重签名、原子互换、闪电网络等。P2SH和Taproot等升级进一步增强了脚本的表达能力,同时保持了简洁性和安全性。

**抗审查性**

P2SH和Taproot等脚本类型将复杂的支付条件隐藏在哈希后,外部观察者无法得知实际的花费条件,这在保护隐私的同时提高了抗审查能力。

## 应用场景

**多重签名钱包**

使用P2SH脚本实现M-of-N多重签名,要求N个密钥中至少M个签名才能花费。例如,2-of-3多重签名可用于公司资金管理,防止单点故障,提高安全性和问责制。这广泛应用于交易所、DAO治理和个人资产保护。

**时间锁定**

通过 `OP_CHECKLOCKTIMEVERIFY` 和 `OP_CHECKSEQUENCEVERIFY` 实现时间锁定,可以指定交易在特定时间或区块高度后才能花费。这用于遗产规划、定期支付、闪电网络的安全机制等场景。

**原子互换**

哈希时间锁合约(HTLC)利用比特币脚本实现跨链原子互换,允许两条不同区块链上的资产无需信任中介即可交换。这是闪电网络和去中心化交易所的基础技术。

**闪电网络**

闪电网络的支付通道利用比特币脚本构建智能合约,实现快速、低成本的链下支付。脚本确保了通道的安全性和公平性,任何一方都可以单方面关闭通道并取回资金。

**条件支付**

脚本可以实现各种条件支付逻辑,如托管服务(资金在满足特定条件后释放)、悬赏(提供正确哈希原像即可领取)等。这为去中心化应用提供了灵活的支付基础。

## 发展历程

**2009年:比特币诞生**

中本聪在比特币最初版本中引入脚本系统,作为灵活定义交易条件的方法。早期主要使用P2PK(支付到公钥)和P2PKH脚本类型。

**2012年:P2SH引入**

BIP16提案引入P2SH(支付到脚本哈希),允许将复杂脚本隐藏在哈希中,只在花费时公开。这极大提升了脚本的灵活性,使得多重签名等高级功能更易实现。

**2015-2016年:时间锁操作码**

BIP65和BIP112分别引入 `OP_CHECKLOCKTIMEVERIFY` 和 `OP_CHECKSEQUENCEVERIFY`,为闪电网络和原子互换提供了关键功能。

**2017年:隔离见证(SegWit)**

BIP141引入隔离见证,将签名数据从交易主体分离,引入了P2WPKH和P2WSH新脚本类型。这修复了交易延展性问题,降低了交易大小,为闪电网络奠定了基础。

**2021年:Taproot激活**

BIP340/341/342引入Taproot和Schnorr签名,提供了P2TR脚本类型并实现了更高的隐私性、更小的交易体积和灵活的脚本树。Taproot允许将多个复杂脚本合并成一个默认公钥,只在需要时公开特定分支,大幅提升了可扩展性和隐私。

## 脚本示例

**P2PKH标准交易**

锁定脚本(ScriptPubKey):
```
OP_DUP OP_HASH160 <公钥哈希> OP_EQUALVERIFY OP_CHECKSIG
```

解锁脚本(ScriptSig):
```
<签名> <公钥>
```

执行流程:
1. 将签名和公钥压入堆栈
2. `OP_DUP` 复制公钥
3. `OP_HASH160` 对公钥进行哈希
4. 比较哈希值与锁定脚本中的公钥哈希
5. `OP_EQUALVERIFY` 验证哈希是否匹配
6. `OP_CHECKSIG` 验证签名有效性

**2-of-3多重签名(P2SH)**

赎回脚本(Redeem Script):
```
OP_2 <公钥A> <公钥B> <公钥C> OP_3 OP_CHECKMULTISIG
```

锁定脚本(ScriptPubKey):
```
OP_HASH160 <赎回脚本哈希> OP_EQUAL
```

解锁脚本(ScriptSig):
```
OP_0 <签名1> <签名2> <赎回脚本>
```

这个脚本要求3个公钥中至少2个有效签名才能花费资金。

## 相关链接

- [比特币脚本维基](https://en.bitcoin.it/wiki/Script)
- [比特币操作码详细列表](https://en.bitcoin.it/wiki/Script#Opcodes)
- [BIP16: P2SH](https://github.com/bitcoin/bips/blob/master/bip-0016.mediawiki)
- [BIP141: 隔离见证](https://github.com/bitcoin/bips/blob/master/bip-0141.mediawiki)
- [BIP341: Taproot](https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki)
- [比特币脚本在线解释器](https://siminchen.github.io/bitcoinIDE/build/editor.html)
