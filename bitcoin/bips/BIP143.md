# BIP143 - 版本 0 见证程序的交易签名验证

BIP143（Bitcoin Improvement Proposal 143）是比特币改进提案之一，由 Johnson Lau 和 Pieter Wuille 在 2016 年提出，定义了隔离见证（SegWit）交易的签名哈希算法。这个提案解决了传统签名验证算法的多个安全和性能问题，是 BIP141（隔离见证）的重要补充。

## 核心概念

在 BIP143 之前，比特币使用的签名哈希算法存在几个严重问题，特别是二次哈希问题（O(n²) 复杂度）和硬件钱包的安全隐患。BIP143 为 SegWit 交易设计了一个全新的签名哈希算法，从根本上解决了这些问题。

BIP143 仅适用于版本 0 的见证程序（witness program），包括 P2WPKH（Pay to Witness Public Key Hash）和 P2WSH（Pay to Witness Script Hash）。这个新算法不仅提高了性能，还增强了安全性，特别是对硬件钱包用户。

## 旧算法的问题

### 1. 二次哈希问题（O(n²) 复杂度）

传统的 SIGHASH 算法在验证交易时存在性能问题：

**问题描述**：
- 每个输入的签名验证需要对整个交易进行哈希
- 对于有 N 个输入的交易，需要进行 N 次完整交易哈希
- 每次哈希都要处理所有 N 个输入
- 总复杂度为 O(N²)

**实际影响**：
```
1 个输入交易：1 次哈希
10 个输入交易：10 次哈希 × 10 个输入 = 100 次操作
100 个输入交易：100 次哈希 × 100 个输入 = 10,000 次操作
```

**攻击向量**：
- 恶意构造大型交易（数百或数千个输入）
- 导致节点验证时间指数级增长
- 可能造成拒绝服务攻击
- 2015 年曾出现验证时间超过 1 分钟的攻击交易

### 2. 硬件钱包安全问题

传统算法对硬件钱包不友好：

**签名时无法验证输入金额**：
- 签名哈希不包含输入金额
- 硬件钱包无法独立验证输入金额
- 恶意主机可能谎报输入金额
- 用户可能在不知情下签署将大部分资金作为手续费的交易

**举例说明**：
```
实际情况：
  输入：10 BTC
  输出：0.1 BTC（接收方）+ 9.9 BTC（找零）
  手续费：0 BTC

恶意主机告诉硬件钱包：
  输入：0.2 BTC
  输出：0.1 BTC（接收方）+ 0.09 BTC（找零）
  手续费：0.01 BTC

硬件钱包显示给用户：手续费 0.01 BTC（看起来合理）
实际手续费：10 - 0.1 - 9.9 = 0 BTC（或更糟，如果找零地址被替换）

用户签名后：
  真实手续费可能高达 9.9 BTC（如果恶意主机移除找零输出）
```

### 3. 离线签名困难

传统算法需要完整的交易数据：
- 硬件钱包需要接收所有输入的完整交易数据
- 数据传输量大，验证复杂
- 增加了攻击面和用户操作复杂度

## BIP143 的解决方案

### 签名哈希算法改进

BIP143 引入了新的签名哈希计算方式：

**新算法特点**：
1. **线性复杂度（O(n)）**：每个哈希操作只进行一次
2. **承诺输入金额**：签名中包含输入金额
3. **缓存友好**：可以预先计算公共哈希值
4. **硬件钱包安全**：可以独立验证所有关键信息

### 签名哈希结构

```
签名哈希 = SHA256(SHA256(
  1. nVersion                      (4 字节)
  2. hashPrevouts                  (32 字节)
  3. hashSequence                  (32 字节)
  4. outpoint                      (36 字节)
  5. scriptCode                    (变长)
  6. value                         (8 字节) ← 新增！
  7. nSequence                     (4 字节)
  8. hashOutputs                   (32 字节)
  9. nLocktime                     (4 字节)
  10. nHashType                    (4 字节)
))
```

### 关键字段详解

#### 1. nVersion
交易版本号（4 字节）

#### 2. hashPrevouts
**所有输入的前序交易输出点的哈希**：
```
hashPrevouts = SHA256(SHA256(所有输入的 outpoint))

outpoint = txid (32 字节) + vout (4 字节)
```

**优势**：
- 只计算一次，可以缓存
- 所有输入共享同一个哈希值
- 从 O(n²) 降低到 O(n)

#### 3. hashSequence
**所有输入的序列号哈希**：
```
hashSequence = SHA256(SHA256(所有输入的 nSequence))
```

**用途**：
- 承诺所有输入的 nSequence 值
- 防止选择性签名攻击
- 支持 BIP68 相对时间锁定

#### 4. outpoint
**当前输入的交易输出点**（36 字节）：
```
outpoint = txid (32 字节) + vout (4 字节)
```

#### 5. scriptCode
**脚本代码**（变长）：

**对于 P2WPKH**：
```
scriptCode = 0x1976a914{20字节公钥哈希}88ac
```
等价于 P2PKH 的脚本：`OP_DUP OP_HASH160 <pubKeyHash> OP_EQUALVERIFY OP_CHECKSIG`

**对于 P2WSH**：
```
scriptCode = 见证脚本（witnessScript）
```

#### 6. value
**输入金额**（8 字节）← **最重要的改进！**

```
value = 该输入花费的 UTXO 的金额（satoshi）
```

**安全意义**：
- 签名时明确承诺输入金额
- 硬件钱包可以独立验证
- 防止恶意主机谎报金额
- 用户可以准确计算手续费

#### 7. nSequence
当前输入的序列号（4 字节）

#### 8. hashOutputs
**所有输出的哈希**：
```
hashOutputs = SHA256(SHA256(所有输出))

每个输出 = value (8 字节) + scriptPubKey (变长)
```

**优势**：
- 只计算一次
- 承诺所有输出
- 硬件钱包可以逐个验证输出后再签名

#### 9. nLocktime
交易锁定时间（4 字节）

#### 10. nHashType
签名哈希类型（4 字节）

## 技术优势

### 1. 性能优化

**旧算法**：
```
对于 N 个输入的交易：
- 每个输入签名需要哈希整个交易
- 总哈希操作：O(N²)
- 大型交易验证时间：指数级增长
```

**新算法（BIP143）**：
```
对于 N 个输入的交易：
- hashPrevouts：计算 1 次，所有输入共享
- hashSequence：计算 1 次，所有输入共享
- hashOutputs：计算 1 次，所有输入共享
- 每个输入只需哈希约 200 字节的数据
- 总哈希操作：O(N)
```

**实际对比**：
```
100 个输入的交易：
- 旧算法：~10,000 次哈希操作（假设每个输入 1KB）
- 新算法：~103 次哈希操作（3 个公共哈希 + 100 个输入）
- 速度提升：约 100 倍
```

### 2. 硬件钱包安全

**输入金额验证**：
```
签名流程：
1. 主机发送：UTXO 金额
2. 硬件钱包计算签名哈希（包含金额）
3. 金额被包含在签名中
4. 如果主机谎报金额，签名将无效
```

**输出验证**：
```
签名流程：
1. 主机逐个发送输出
2. 硬件钱包显示每个输出给用户确认
3. 硬件钱包计算 hashOutputs
4. hashOutputs 包含在签名中
5. 任何输出被修改，签名将无效
```

**手续费计算**：
```
硬件钱包可以安全计算：
  总输入 = Σ(输入金额)  ← 包含在签名中
  总输出 = Σ(输出金额)  ← 包含在签名中
  手续费 = 总输入 - 总输出

显示给用户：准确的手续费
```

### 3. 离线签名优化

**最小数据需求**：
硬件钱包只需要：
- 当前输入的 UTXO 信息（txid、vout、金额、脚本）
- 所有输出的列表
- hashPrevouts、hashSequence（可以预先计算或主机提供）

**无需完整交易历史**：
- 不需要所有输入的完整前序交易
- 减少数据传输量
- 简化用户操作

## SIGHASH 类型支持

BIP143 支持所有传统的 SIGHASH 类型：

### SIGHASH_ALL（0x01）
签名所有输入和输出：
```
hashPrevouts = SHA256(SHA256(所有 outpoints))
hashSequence = SHA256(SHA256(所有 nSequence))
hashOutputs = SHA256(SHA256(所有输出))
```

### SIGHASH_NONE（0x02）
签名所有输入，但不签名输出：
```
hashPrevouts = SHA256(SHA256(所有 outpoints))
hashSequence = 0x0000...0000（32 个零）
hashOutputs = 0x0000...0000（32 个零）
```

### SIGHASH_SINGLE（0x03）
签名所有输入和对应索引的输出：
```
hashPrevouts = SHA256(SHA256(所有 outpoints))
hashSequence = 0x0000...0000（32 个零）
hashOutputs = SHA256(SHA256(对应索引的输出))
```

### SIGHASH_ANYONECANPAY（0x80）
可以与上述类型组合，只签名当前输入：
```
hashPrevouts = 0x0000...0000（32 个零）
hashSequence = 0x0000...0000（32 个零）
hashOutputs = 根据组合的 SIGHASH 类型决定
```

## 实际应用

### 硬件钱包（Ledger、Trezor 等）

**安全的签名流程**：
1. 用户在硬件钱包上发起交易
2. 主机应用构建交易并发送给硬件钱包
3. 硬件钱包逐个显示输出地址和金额，要求用户确认
4. 硬件钱包计算并显示总手续费
5. 用户确认后，硬件钱包签名（金额和输出都包含在签名中）
6. 即使主机应用是恶意的，也无法在用户确认后修改交易

### 批量支付

**优化的签名性能**：
- 交易所或支付服务商需要处理大量输出的交易
- 例如：1 个输入 + 1000 个输出（批量发工资）
- BIP143 使得这类交易的签名和验证都更快
- 节点可以快速验证大型批量支付交易

### 闪电网络

**承诺交易的安全性**：
- 闪电网络的承诺交易可能有多个输入
- BIP143 确保签名验证高效
- 输入金额的承诺增强了通道安全性

## 与其他 BIP 的关系

### BIP141（隔离见证）

BIP143 是 BIP141 的配套提案：
- BIP141 定义了见证数据的结构
- BIP143 定义了见证交易的签名算法
- 两者共同构成完整的 SegWit 实现

### BIP144（点对点服务）

BIP144 定义了网络传输格式：
- 节点间传输见证数据
- BIP143 签名的验证发生在接收端

### BIP341（Taproot）

Taproot 使用不同的签名算法：
- Taproot 使用 BIP340（Schnorr 签名）
- 但签名哈希算法借鉴了 BIP143 的设计
- 同样承诺输入金额和线性复杂度

## 安全注意事项

### 1. 输入金额验证

**硬件钱包实现必须**：
- 独立获取和验证 UTXO 金额
- 在计算签名哈希前验证金额
- 向用户显示准确的手续费

### 2. 输出哈希验证

**必须验证所有输出**：
- 逐个向用户显示输出地址和金额
- 在用户确认后计算 hashOutputs
- 确保 hashOutputs 在签名后不被修改

### 3. 重放保护

虽然 BIP143 本身不提供重放保护，但：
- 输入金额的承诺使得跨链重放攻击更难
- 配合其他机制（如不同的币种类型）可以防止重放

## 实现细节

### 伪代码示例

```python
def SignatureHash(scriptCode, txTo, inIdx, hashType, value):
    """
    计算 BIP143 签名哈希

    参数：
    - scriptCode: 脚本代码
    - txTo: 要签名的交易
    - inIdx: 当前输入的索引
    - hashType: 签名哈希类型
    - value: 输入金额（satoshi）
    """

    # 1. nVersion
    hashPrevouts = b'\x00' * 32
    hashSequence = b'\x00' * 32
    hashOutputs = b'\x00' * 32

    # 2. hashPrevouts
    if not (hashType & SIGHASH_ANYONECANPAY):
        hashPrevouts = GetHashPrevouts(txTo)

    # 3. hashSequence
    if (not (hashType & SIGHASH_ANYONECANPAY) and
        (hashType & 0x1f) != SIGHASH_SINGLE and
        (hashType & 0x1f) != SIGHASH_NONE):
        hashSequence = GetHashSequence(txTo)

    # 4. hashOutputs
    if (hashType & 0x1f) not in [SIGHASH_SINGLE, SIGHASH_NONE]:
        hashOutputs = GetHashOutputs(txTo)
    elif ((hashType & 0x1f) == SIGHASH_SINGLE and
          inIdx < len(txTo.vout)):
        hashOutputs = SHA256(SHA256(txTo.vout[inIdx].serialize()))

    # 构建签名哈希原像
    ss = b''
    ss += struct.pack('<I', txTo.nVersion)
    ss += hashPrevouts
    ss += hashSequence
    ss += txTo.vin[inIdx].prevout.serialize()
    ss += SerializeScriptCode(scriptCode)
    ss += struct.pack('<Q', value)  # 输入金额
    ss += struct.pack('<I', txTo.vin[inIdx].nSequence)
    ss += hashOutputs
    ss += struct.pack('<I', txTo.nLockTime)
    ss += struct.pack('<I', hashType)

    return SHA256(SHA256(ss))


def GetHashPrevouts(tx):
    """计算所有输入的前序输出点哈希"""
    ss = b''
    for inp in tx.vin:
        ss += inp.prevout.serialize()
    return SHA256(SHA256(ss))


def GetHashSequence(tx):
    """计算所有输入的序列号哈希"""
    ss = b''
    for inp in tx.vin:
        ss += struct.pack('<I', inp.nSequence)
    return SHA256(SHA256(ss))


def GetHashOutputs(tx):
    """计算所有输出的哈希"""
    ss = b''
    for out in tx.vout:
        ss += out.serialize()
    return SHA256(SHA256(ss))
```

## 对比：BIP143 前后

| 特性 | 传统 SIGHASH | BIP143 |
|------|-------------|--------|
| 复杂度 | O(n²) | O(n) |
| 大型交易验证 | 慢（可能超过 1 分钟） | 快（几秒） |
| 输入金额承诺 | 无 | 有 |
| 硬件钱包安全 | 无法独立验证 | 可以独立验证 |
| 缓存优化 | 不支持 | 支持 |
| DoS 攻击风险 | 高 | 低 |
| 数据传输量（硬件钱包） | 大（需要完整交易） | 小（只需关键数据） |

## 实际影响

### 对用户的影响

**硬件钱包用户**：
- 更安全：可以准确验证手续费
- 更快：签名速度提升
- 更简单：数据传输量减少

**普通用户**：
- 更快的交易确认（节点验证更快）
- 降低了网络拥堵风险
- 支持更复杂的交易类型

### 对开发者的影响

**钱包开发**：
- 需要实现新的签名算法
- 硬件钱包可以提供更好的用户体验
- 简化了离线签名的实现

**节点软件**：
- 验证性能显著提升
- 抵御 DoS 攻击能力增强
- 支持更大规模的批量交易

### 对网络的影响

**性能提升**：
- 区块验证速度更快
- 可以安全处理更大的交易
- 降低了验证节点的硬件要求

**安全性增强**：
- 消除了二次哈希攻击向量
- 提高了硬件钱包的安全性
- 减少了签名相关的安全隐患

## 激活与部署

### 软分叉激活

BIP143 作为 SegWit 升级的一部分于 2017 年 8 月激活：
- **激活方式**：BIP9 版本位 bit 1
- **激活高度**：481,824（2017 年 8 月 24 日）
- **与 BIP141 同时激活**
- **向后兼容**：旧节点将 SegWit 交易视为"任何人可花费"

### 兼容性

**新旧交易类型**：
- 传统交易（非 SegWit）：继续使用旧的 SIGHASH 算法
- SegWit v0 交易（P2WPKH、P2WSH）：使用 BIP143 算法
- SegWit v1 交易（Taproot）：使用 BIP341 定义的新算法

**钱包支持**：
主流钱包都已实现 BIP143：
- **硬件钱包**：Ledger、Trezor、Coldcard 全面支持
- **软件钱包**：Bitcoin Core、Electrum、Wasabi 等
- **企业方案**：BitGo、Coinbase 等

## 未来发展

### Taproot 的借鉴

BIP341（Taproot）的签名哈希算法：
- 借鉴了 BIP143 的设计理念
- 同样承诺输入金额
- 同样使用 O(n) 复杂度
- 进一步优化和扩展

### 批量验证

基于 BIP143 的进一步优化：
- Schnorr 签名的批量验证
- 跨输入签名聚合
- 更高效的区块验证

## 总结

BIP143 通过改进签名哈希算法，为隔离见证交易带来了显著的性能和安全提升：

**核心改进**：
- **性能**：从 O(n²) 降低到 O(n)，消除了二次哈希问题
- **安全**：承诺输入金额，保护硬件钱包用户
- **效率**：支持缓存，优化签名和验证速度
- **简化**：减少离线签名的数据需求

**实际价值**：
- 消除了基于大型交易的 DoS 攻击向量
- 使硬件钱包可以安全地显示准确的手续费
- 提高了节点验证大型交易的能力
- 为 Taproot 等后续升级奠定了基础

BIP143 虽然是技术性很强的提案，但其影响深远。它不仅解决了长期存在的性能和安全问题，还为比特币网络的扩展和安全使用提供了坚实基础。对于硬件钱包用户而言，BIP143 是保护资金安全的关键技术；对于比特币网络而言，它是抵御攻击、提升性能的重要升级。
