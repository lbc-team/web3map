# BIP62 - 处理延展性

BIP62（Bitcoin Improvement Proposal 62）是比特币改进提案之一，由 Pieter Wuille 在 2014 年提出，旨在通过定义一系列规则来减少或消除交易延展性问题。虽然该提案最终未被激活为共识规则，但其分析和解决方案对比特币协议的发展产生了深远影响，为后续的隔离见证（BIP141）等重大升级奠定了理论基础。

## 核心概念

交易延展性（Transaction Malleability）是指交易在被确认前，其交易 ID（txid）可以被修改的问题。尽管延展性攻击不会导致资金被盗，但会改变交易的唯一标识符，破坏依赖该交易 ID 的后续交易，给智能合约、闪电网络等高级应用带来严重问题。

BIP62 识别了七种主要的延展性来源，并为每种来源提出了相应的限制规则。这些规则通过标准化交易格式，消除了第三方修改交易 ID 的能力，使得交易在广播后到确认前保持稳定的标识符。

## 问题背景

### 什么是交易延展性

交易 ID 是交易内容的 SHA256 双重哈希：

```
txid = SHA256(SHA256(序列化的交易数据))
```

**延展性问题**：
- 交易的某些部分可以在不影响有效性的情况下被修改
- 修改后的交易仍然有效，但 txid 改变
- 原始交易和修改后的交易只有一个能被确认
- 但无法预测哪个版本会被确认

### 延展性的危害

**1. 破坏交易链**：
```
场景：Alice 创建交易 A，Bob 基于 A 创建交易 B

步骤 1：Alice 广播交易 A（txid = 0x123...）
步骤 2：Bob 创建交易 B，输入引用 0x123...
步骤 3：第三方修改交易 A 的签名，得到交易 A'（txid = 0x456...）
步骤 4：交易 A' 被确认，而非交易 A
步骤 5：交易 B 失效，因为 0x123... 不存在

结果：Bob 的交易永远无法确认
```

**2. 欺诈声称未收到款**：
```
场景：Alice 向交易所提现

步骤 1：交易所创建提现交易 T1（txid = 0xAAA...）
步骤 2：Alice 修改 T1 得到 T1'（txid = 0xBBB...）
步骤 3：T1' 被确认，Alice 实际收到了钱
步骤 4：交易所查询 0xAAA...，发现未确认
步骤 5：Alice 声称未收到款，要求重新提现
步骤 6：交易所可能被欺骗，再次支付

结果：Alice 可能获得双倍提现（如果交易所系统不完善）
```

**3. 阻碍 Layer2 发展**：
- 闪电网络需要构建未确认交易的链
- 智能合约需要提前知道交易 ID
- 原子交换需要可靠的交易引用
- 延展性使这些应用变得不安全或不可行

### 历史事件

**2014 年 Mt.Gox 事件**：
- 当时最大的比特币交易所 Mt.Gox 破产
- 部分原因归咎于交易延展性攻击
- 用户通过修改提现交易的 txid
- 声称未收到款，获得重复提现
- 虽然延展性不是 Mt.Gox 倒闭的唯一原因，但暴露了问题严重性

## 延展性来源

BIP62 识别了七种主要的延展性来源：

### 1. 签名的延展性

**问题**：
ECDSA 签名本身存在延展性。对于签名 (r, s)，(r, -s mod n) 也是有效签名。

**示例**：
```
原始签名：(r, s)
修改签名：(r, n - s)  其中 n 是椭圆曲线的阶

两个签名都能通过验证，但产生不同的 txid
```

**BIP62 规则 1**：
要求签名使用低 S 值（Low S）：
```
if (s > n/2) {
    s = n - s
}
```

**实施状态**：
- 已通过 BIP66（严格 DER 签名）部分解决
- Bitcoin Core 0.11.1 后成为标准交易规则
- 2017 年 SegWit 完全消除签名延展性

### 2. 非 DER 编码的签名

**问题**：
DER（Distinguished Encoding Rules）编码允许多种有效表示：
- 长度字段可以有多余的零
- 整数可以有前导零
- 签名可以添加额外的填充

**示例**：
```
标准 DER：  30 44 02 20 [r] 02 20 [s]
非标准 DER：30 45 02 21 00 [r] 02 20 [s]  ← 额外的 00
```

**BIP62 规则 2**：
强制使用严格的 DER 编码（Strict DER）。

**实施状态**：
- BIP66 于 2015 年 7 月激活，强制严格 DER
- 成为共识规则，完全解决此问题

### 3. 脚本中的额外数据

**问题**：
某些脚本操作允许添加额外数据而不影响执行：

**示例**：
```
原始脚本：<sig> <pubkey>
修改脚本：<sig> OP_NOP <pubkey>

或

原始脚本：OP_0
修改脚本：OP_0 OP_0 OP_DROP
```

**BIP62 规则 3**：
禁止在脚本中添加无意义的操作。

**实施状态**：
- 部分通过标准交易规则实施
- SegWit 通过移除签名数据完全解决

### 4. scriptPubKey 类型的延展性

**问题**：
某些输出脚本类型允许多种表示：

**示例**：
```
标准 P2PK： <pubkey> OP_CHECKSIG
替代形式： <pubkey> OP_NOP OP_CHECKSIG

或

OP_0 可以写成 OP_FALSE
OP_1 可以写成 OP_TRUE
```

**BIP62 规则 4**：
标准化 scriptPubKey 的格式。

**实施状态**：
- 通过 IsStandard() 检查部分实施
- 限制了非标准脚本的传播

### 5. scriptSig 的推送操作

**问题**：
推送数据到栈可以使用不同的操作码：

**示例**：
```
推送 75 字节数据：
方式 1：OP_PUSHDATA1 0x4b [75 字节数据]
方式 2：0x4b [75 字节数据]  ← 最小编码

推送 0：
方式 1：OP_0
方式 2：OP_PUSHDATA1 0x00
方式 3：0x00  ← 空字节串
```

**BIP62 规则 5**：
要求使用最小推送操作（Minimal Push）：
- 0-75 字节：直接推送
- 76-255 字节：OP_PUSHDATA1
- 256-65535 字节：OP_PUSHDATA2
- 65536+ 字节：OP_PUSHDATA4

**实施状态**：
- Bitcoin Core 0.11.1 后成为标准规则
- 未成为共识规则（BIP62 未激活）

### 6. 虚假的推送操作

**问题**：
scriptSig 可以包含永远不会被使用的数据：

**示例**：
```
P2SH 赎回脚本：2 <pubkey1> <pubkey2> 2 OP_CHECKMULTISIG

标准 scriptSig：OP_0 <sig1> <sig2> <redeem script>
修改 scriptSig：OP_0 <sig1> <sig2> <额外数据> OP_DROP <redeem script>
```

**BIP62 规则 6**：
禁止 scriptSig 中有未使用的推送操作。

**实施状态**：
- 难以在不破坏兼容性的情况下强制执行
- SegWit 通过见证数据结构解决

### 7. OP_CHECKMULTISIG 的虚假栈元素

**问题**：
由于历史 bug，OP_CHECKMULTISIG 会多弹出一个栈元素：

**示例**：
```
2-of-3 多签：
正常情况：OP_0 <sig1> <sig2> | 2 <pk1> <pk2> <pk3> 3 OP_CHECKMULTISIG

修改延展性：
OP_0 可以替换为 OP_1, OP_1NEGATE, 或任何数据
只要该元素被弹出即可
```

**BIP62 规则 7**：
要求 OP_CHECKMULTISIG 的虚假栈元素必须是 OP_0。

**实施状态**：
- Bitcoin Core 0.10+ 成为标准规则
- BIP147（2017 年激活）将其作为共识规则

## 技术细节

### 严格 DER 签名（BIP66）

DER 编码的严格规则：

```
签名格式：
0x30 [total-length] 0x02 [R-length] [R] 0x02 [S-length] [S] [sighash-type]

严格要求：
1. 总长度必须等于实际长度
2. R 和 S 必须是最小长度编码（无前导零，除非最高位为 1）
3. R 和 S 必须为正数
4. S 必须 ≤ n/2（低 S 值）
5. sighash 类型必须定义（0x01, 0x02, 0x03, 0x81 等）
```

### 低 S 值验证

```python
def verify_low_s(signature):
    """验证签名使用低 S 值"""
    r, s = decode_signature(signature)

    # secp256k1 曲线的阶
    n = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141

    # 检查 s <= n/2
    if s > n // 2:
        return False

    return True
```

### 最小推送验证

```python
def verify_minimal_push(opcode, data):
    """验证使用最小推送操作"""
    data_len = len(data)

    if data_len == 0:
        return opcode == OP_0
    elif data_len == 1:
        if 1 <= data[0] <= 16:
            return opcode == OP_1 + (data[0] - 1)
        elif data[0] == 0x81:
            return opcode == OP_1NEGATE
        else:
            return opcode == 0x01
    elif data_len <= 75:
        return opcode == data_len
    elif data_len <= 255:
        return opcode == OP_PUSHDATA1
    elif data_len <= 65535:
        return opcode == OP_PUSHDATA2
    else:
        return opcode == OP_PUSHDATA4
```

## BIP62 的命运

### 提案状态

BIP62 提出后经历了漫长的讨论：

**2014 年**：提案发布，识别七种延展性来源

**2015 年**：部分规则被采纳
- BIP66（严格 DER）激活，解决规则 2
- 低 S 值成为标准规则

**2016-2017 年**：BIP62 作为软分叉的计划被搁置
- 发现完全实施存在技术挑战
- 某些规则难以强制执行
- 决定通过 SegWit 从根本上解决问题

**最终结果**：
- BIP62 从未作为共识规则激活
- 标记为"已撤回"（Withdrawn）
- 但其分析和部分规则仍被采纳

### 为何未激活

**技术挑战**：
- 规则 5、6 难以在不破坏兼容性的情况下强制执行
- 某些边缘情况处理复杂
- 可能影响现有脚本的有效性

**更好的解决方案**：
- SegWit（BIP141）提供了更彻底的解决方案
- 通过分离见证数据，完全消除第三方延展性
- SegWit 还带来了其他好处（容量提升、签名优化等）

**社区共识**：
- 2016 年社区决定专注于 SegWit
- SegWit 能一次性解决多个问题
- 避免多次软分叉的复杂性

## 与其他 BIP 的关系

### BIP66（严格 DER 签名）

BIP66 实现了 BIP62 的规则 2：
- 2015 年 7 月激活
- 强制所有签名使用严格 DER 编码
- 消除了 DER 编码的延展性

### BIP141（隔离见证）

SegWit 彻底解决了延展性问题：

```
SegWit 之前：
txid = SHA256(SHA256(版本 + 输入 + 输出 + 锁定时间))
输入包含签名数据，签名可被修改 → txid 可变

SegWit 之后：
txid = SHA256(SHA256(版本 + 输入（无签名）+ 输出 + 锁定时间))
签名在见证数据中，不影响 txid → txid 不可变
```

**完全消除第三方延展性**：
- 签名数据不再计入 txid
- 第三方无法修改 txid
- 仅交易创建者可以通过修改输入脚本修改 txid（但这需要私钥）

### BIP147（OP_CHECKMULTISIG 虚假元素）

BIP147 实现了 BIP62 的规则 7：
- 2017 年 8 月与 SegWit 同时激活
- 强制 OP_CHECKMULTISIG 的虚假元素为 OP_0
- 进一步减少延展性向量

### BIP143（SegWit 签名哈希）

BIP143 为 SegWit 交易定义了新的签名算法：
- 签名时承诺输入金额
- 防止某些类型的延展性
- 提高硬件钱包安全性

## 已实施的规则

虽然 BIP62 整体未激活，但部分规则已通过其他方式实施：

### 标准交易规则

Bitcoin Core 将以下规则作为 IsStandard() 检查：

**低 S 值**（规则 1）：
- 自 0.11.1 版本起强制执行
- 非标准交易不会被中继
- 但矿工仍可将其打包

**最小推送**（规则 5）：
- 自 0.11.1 版本起强制执行
- 提高了标准交易的一致性

**OP_CHECKMULTISIG 虚假元素**（规则 7）：
- 自 0.10.0 版本起为标准规则
- BIP147 升级为共识规则

### 共识规则

**BIP66**（规则 2）：
- 严格 DER 编码
- 2015 年 7 月激活

**BIP147**（规则 7）：
- OP_CHECKMULTISIG 虚假元素必须为 OP_0
- 2017 年 8 月激活

## 实际影响

### 对用户的影响

**交易所和钱包**：
- 需要实施健壮的 txid 跟踪机制
- 不能仅依赖 txid 判断交易是否确认
- 应验证输入和输出，而非仅验证 txid

**最佳实践**：
```
不佳做法：
if (txid == expected_txid) {
    // 认为交易已确认
}

正确做法：
if (transaction.inputs == expected_inputs &&
    transaction.outputs == expected_outputs &&
    transaction.confirmations >= 6) {
    // 交易确认且内容正确
}
```

### 对开发者的影响

**未确认交易链**：
- SegWit 前：不安全，应避免
- SegWit 后：安全，闪电网络等成为可能

**智能合约**：
- SegWit 前：依赖 txid 的合约不安全
- SegWit 后：可以安全引用父交易

### 对生态的影响

**闪电网络**：
- 需要构建未确认交易的链
- 延展性修复是先决条件
- SegWit 激活后，闪电网络快速发展

**原子交换**：
- HTLC 需要可靠的 txid
- 延展性修复使跨链原子交换成为可能

## 安全注意事项

### 开发者指南

**1. 不要仅依赖 txid**：
```python
# 错误示例
def check_payment(expected_txid):
    tx = blockchain.get_transaction(expected_txid)
    return tx.confirmed

# 正确示例
def check_payment(expected_address, expected_amount):
    txs = blockchain.get_transactions_to(expected_address)
    for tx in txs:
        if tx.amount == expected_amount and tx.confirmations >= 6:
            return True
    return False
```

**2. 使用 SegWit 地址**：
- 优先使用原生 SegWit（bc1q...）
- 或嵌套 SegWit（3... 开头）
- 完全避免第三方延展性

**3. 监控所有交易版本**：
- 跟踪相同输入的所有交易
- 识别哪个版本被确认
- 及时更新内部记录

### 交易所安全

**提现系统**：
```
1. 创建提现交易 T
2. 记录交易的输入和输出，而非仅 txid
3. 广播交易
4. 监控区块链，查找匹配输入/输出的交易
5. 发现确认后，无论 txid 是否匹配，标记为完成
6. 不响应"txid 未确认"的投诉（验证输入/输出）
```

**双重支付检测**：
- 监控所有花费相同 UTXO 的交易
- 识别延展性修改 vs 真正的双花
- 区别对待，采取不同措施

## 对比：BIP62 vs SegWit

| 特性 | BIP62 | SegWit（BIP141） |
|------|-------|------------------|
| 解决延展性 | 部分（七种规则） | 完全（第三方延展性） |
| 实施复杂度 | 高（多个独立规则） | 中（统一架构） |
| 其他好处 | 无 | 容量提升、签名优化 |
| 激活状态 | 未激活（撤回） | 已激活（2017 年） |
| 向后兼容 | 软分叉 | 软分叉 |
| 社区支持 | 分裂 | 最终达成共识 |
| 对闪电网络 | 不足 | 完全支持 |
| 对智能合约 | 部分改进 | 根本解决 |

## 历史意义

### BIP62 的贡献

尽管未被激活，BIP62 仍然重要：

**理论基础**：
- 系统性分析了延展性问题
- 识别了所有主要延展性来源
- 为后续解决方案提供了框架

**部分实施**：
- 低 S 值成为标准规则
- 严格 DER 通过 BIP66 实施
- OP_CHECKMULTISIG 修复通过 BIP147 实施

**推动 SegWit**：
- BIP62 的挑战促使社区寻求更好方案
- SegWit 作为综合解决方案应运而生
- 一次性解决延展性及其他问题

### 教训

**1. 复杂问题需要综合方案**：
- 逐个修补延展性来源效率低
- SegWit 通过架构改变一劳永逸
- 避免了多次软分叉的风险

**2. 标准规则 vs 共识规则**：
- 标准规则可以快速迭代
- 共识规则需要谨慎、充分测试
- 两者配合可以渐进式改进

**3. 社区协调的重要性**：
- 技术方案需要社区共识
- 多个小升级 vs 一个大升级的权衡
- 充分讨论避免了方向错误

## 总结

BIP62 是比特币历史上一个重要的提案，虽然最终未被激活，但其影响深远：

**核心贡献**：
- **系统分析**：首次全面识别了七种延展性来源
- **理论基础**：为延展性问题的解决提供了框架
- **部分实施**：通过标准规则和其他 BIP 部分解决问题
- **推动创新**：促使社区开发出更好的 SegWit 方案

**实际价值**：
- 严格 DER（BIP66）消除了签名编码延展性
- 低 S 值规则减少了签名延展性
- OP_CHECKMULTISIG 修复（BIP147）消除了多签延展性
- 为 SegWit 的设计和激活铺平了道路

**历史意义**：
- 展示了比特币社区的技术深度和迭代能力
- 证明了有时候"更好的方案"值得等待
- BIP62 → SegWit 的演进是比特币渐进式改进的典范
- 为闪电网络等革命性技术的发展清除了障碍

**最终结局**：
虽然 BIP62 作为独立软分叉未能激活，但其识别的问题已通过 SegWit（BIP141）彻底解决。SegWit 不仅消除了第三方延展性，还带来了容量提升、签名优化等额外好处。可以说，BIP62 的"失败"实际上是比特币协议演进过程中的一次成功——通过充分讨论和技术探索，社区找到了更优的解决方案。

今天，在 SegWit 广泛采用的情况下，交易延展性已不再是比特币的主要问题。闪电网络、智能合约、原子交换等依赖稳定 txid 的高级应用得以蓬勃发展。BIP62 的分析和探索，以及最终被 SegWit 取代的过程，完美诠释了比特币作为开源协议的演进哲学：不断试错、充分讨论、择优采纳、持续改进。
